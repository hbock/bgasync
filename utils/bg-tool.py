"""
Test utility to gather information on the device supporting BGAPI
(version information, flash, etc), and to perform various operations
(clear persistent store, bonding information, etc.)
"""
import sys
import argparse
import binascii
import serial

from bgasync.api import *
from bgasync.twisted.protocol import BluegigaProtocol

from twisted.internet.serialport import SerialPort
from twisted.internet.defer import inlineCallbacks
from twisted.internet.defer import Deferred
from twisted.internet import reactor
from twisted.python import log

def print_system_info(response):
    print("System information:\n  * Software version {}.{}.{} build {}\n  * Hardware version {}".format(
        response.major, response.minor, response.patch, response.build, response.hw
    ))
    print("  * LL version {}".format(response.ll_version))

@inlineCallbacks
def devinfo_response_cb(response, protocol):
    print_system_info(response)

    response = yield protocol.send_command(command_system_address_get())
    print("Bluetooth address: {}".format(get_address_string_from_bytes(response.address)))

    response = yield protocol.send_command(command_system_get_counters())
    print("Device counters:\n"
          "  * TX frames {} (retry {})\n"
          "  * RX frames {} (fail {})\n"
          "  * Buffer count: {}".format(
        response.txok, response.txretry,
        response.rxok, response.rxfail,
        response.mbuf
    ))

    # If system_get_connections() is sent before flash_ps_dump(), we don't
    # get the events for the PS dump.  Somehow we need to wait for expected
    # connection_status events?
    response = yield protocol.send_command(command_system_get_connections())
    print("Max supported connections: {}".format(response.maxconn))

    # flash_ps_dump() provides no useful response, so we ignore it.
    yield protocol.send_command(command_flash_ps_dump())

    # Wait 3 seconds, and terminate.
    reactor.callLater(3, reactor.stop)

class AppProtocol(BluegigaProtocol):
    def __init__(self):
        super(AppProtocol, self).__init__()

        # Wait on connection status
        self.waiting_for_connection_status_count = 0
        self.waiting_for_connection_status_list = []
        self.waiting_for_connection_status_deferred = None

    def get_connection_status(self):
        """
        Request the status of all connections, active or not.

        :return: A Deferred that will be called back with a
                 list of connection status events.
        """
        self.waiting_for_connection_status_deferred = Deferred()

        def connstatus_resp_cb(response):
            self.waiting_for_connection_status_count = response.maxconn
            self.waiting_for_connection_status_list = []

        d = self.send_command(command_system_get_connections())
        d.addCallback(connstatus_resp_cb)

        return self.waiting_for_connection_status_deferred

    def handle_event_connection_status(self, status):
        """
        Events for connection status generated by command_system_get_connections().
        """
        # If we're waiting for a specific number of connection status events,
        # append them to the internal status list until we get all
        # the required events.
        if self.waiting_for_connection_status_count:
            status_list = self.waiting_for_connection_status_list
            status_list.append(status)

            # We've received the status events we need, call back
            # the deferred of the client requesting status.
            if len(status_list) == self.waiting_for_connection_status_count:
                self.waiting_for_connection_status_deferred.callback(status_list)

    # Events generated by command_flash_ps_dump;
    # One per PS key plus one key=0xFFFF to indicate the end.
    def handle_event_flash_ps_key(self, event):
        if event.key == 0xFFFF:
            # 0xFFFF indicates last value; terminate program
            reactor.stop()

        else:
            print("  Key {:05d}: {}".format(event.key, binascii.hexlify(event.value)))

    def handle_event_sm_bond_status(self, event):
        print("SM bond status: {}".format(event))

    def connectionLost(self, reason=None):
        # Serial port went away; stop the reactor
        print("Serial port connection lost!")
        reactor.stop()

def bgtool_devinfo(protocol, args):
    """ Retrieve BLE(D) device information """
    d = protocol.send_command(command_system_get_info())
    d.addCallback(devinfo_response_cb, protocol)

def list_bonds_response_cb(response, protocol, args):
    print("  Number of active bonds: {}".format(response.bonds))
    reactor.stop()

def delete_bonds_response_cb(response, protocol, args):
    print("  Result: {}".format(get_error_code_string(response.result)))
    reactor.stop()

def bgtool_bonds(protocol, args):
    """ Perform a system reset of the BGAPI device """
    if args.delete_all:
        print("Deleting all bonds.")

        d = protocol.send_command(command_sm_delete_bonding(handle=0xFF))
        d.addCallback(delete_bonds_response_cb, protocol, args)

    else:
        print("Listing bonded devices: ")
        d = protocol.send_command(command_sm_get_bonds())
        d.addCallback(list_bonds_response_cb, protocol, args)

def bgtool_reset(protocol, args):
    """ Perform a system reset of the BGAPI device """
    dfu = 1 if args.dfu else 0
    d = protocol.send_command(command_system_reset(boot_in_dfu=dfu))
    # FIXME: reset doesn't get a response, and causes the BLED112 dongle
    # serial port to go away (expected).  Twisted calls connectionLost()
    # but there is still an exception on win32.

def ps_clear_cb(response, protocol):
    print("Cleared.  The device will now reset.")
    protocol.send_command(command_system_reset(boot_in_dfu=0))
    reactor.callLater(1, reactor.stop)

def ps_defrag_cb(response, protocol):
    print("  Flash defragmented.")
    reactor.stop()

def bgtool_ps(protocol, args):
    if "dump" == args.action:
        print("Dumping persistent store: ")
        # No need for a callback; we'll just wait for flash_ps_key events.
        protocol.send_command(command_flash_ps_dump())

    elif "clear" == args.action:
        print("Clearing all persistent store keys...")
        d = protocol.send_command(command_flash_ps_erase_all())
        d.addCallback(ps_clear_cb, protocol)

    elif "defrag" == args.action:
        print("Defragmenting persistent store...")
        d = protocol.send_command(command_flash_ps_defrag())
        d.addCallback(ps_defrag_cb, protocol)

def bgtool_connections(protocol, args):
    def connstatus_list_cb(status_list):
        connected_count = 0

        for status in status_list:
            # Only log active connections.
            if status.flags & connection_connstatus.connected.value:
                connected_count += 1

                attributes = []
                attributes.append("Address: {}".format(get_address_string_from_bytes(status.address)))
                attributes.append("connection interval: {} ({} ms)".format(
                    status.conn_interval, 1.25 * status.conn_interval
                ))
                attributes.append("link supervision timeout: {} ms".format(
                    status.timeout * 10
                ))
                attributes.append("slave latency: {} events".format(
                    status.latency
                ))
                if 0xFF != status.bonding:
                    attributes.append("bonded")
                else:
                    attributes.append("not bonded")

                print("  {}".format(", ".join(attributes)))

        if 0 == connected_count:
            print("  No active connections.")

        reactor.stop()

    print("Querying connection status: ")
    d = protocol.get_connection_status()
    d.addCallback(connstatus_list_cb)


def bgtool_run(protocol, args):
    cmd = args.subparser_name
    cmd_vector = {
        "ps":          bgtool_ps,
        "bonds":       bgtool_bonds,
        "devinfo":     bgtool_devinfo,
        "reset":       bgtool_reset,
        "connections": bgtool_connections,
    }

    try:
        cmd_vector[cmd](protocol, args)

    except KeyError:
        sys.stderr.write("Unknown command: {}\n".format(cmd))
        sys.exit(1)

def main():
    parser = argparse.ArgumentParser()

    # Positional
    parser.add_argument("serial_port", help="Serial/COM port connected to the Bluegiga device.")
    # Optional
    parser.add_argument("-v", "--verbose", action="store_true", help="Verbose log output")

    subparsers = parser.add_subparsers(dest='subparser_name', help='sub-command help')

    parser_devinfo = subparsers.add_parser('devinfo', help='Get device information')

    parser_bonds = subparsers.add_parser('bonds', help='Access bonds')
    parser_bonds.add_argument("--delete-all", action="store_true", help="Delete all bonds")

    parser_ps = subparsers.add_parser('ps', help='Access the device persistent store')
    parser_ps.add_argument("action", help="Persistent store action (dump, clear, delete, defrag, save)")

    parser_connections = subparsers.add_parser('connections', help='Get status of active connections')

    parser_reset = subparsers.add_parser('reset', help='Reset device')
    parser_reset.add_argument("--dfu", action="store_true", help="Boot into Device Firmware Update (DFU) mode")

    args = parser.parse_args()
    if args.verbose:
        log.startLogging(sys.stderr, setStdout=False)

    protocol = AppProtocol()

    try:
        port = SerialPort(protocol, args.serial_port, reactor, baudrate=256000)

    except serial.SerialException as err:
        sys.stderr.write("Error opening serial port: {}".format(err))
        sys.exit(1)

    bgtool_run(protocol, args)

    reactor.run()

if __name__ == "__main__":
    main()